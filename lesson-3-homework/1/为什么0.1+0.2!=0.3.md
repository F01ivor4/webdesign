#### 为什么$0.1+0.2!=0.3$ ?

#### 1.IEEE754标准

首先我们要先明白浮点数在``Javascript`` 中怎么保存。事实上，``Javascript``中的浮点数按照 **IEEE754** 标准储存。在**IEEE754** 标准中，常用的两种浮点数值的表示方式为：单精确度（32位）、双精确度（64位）。而 ``Javascript`` 中使用的是双精度表示方式。即一个浮点数需要转化成二进制，用``64bits`` 来保存，且``64bits``分为以下几个部分：

1. 符号部分：用一个``bit``表示，0 为 正 1 为 负。
2. 指数部分：用``11 bits``表示，用来表示次方数。
3. 尾数部分：用``52 bits``表示，用来表示尾数。IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，只保存后面部分，这样可以节省 1 位有效数字，对于双精度 64 位浮点数，M 为 52 位，将第一位的 1 舍去，可以保存的有效数字为 52 + 1 = 53 位。

以0.1为例，0.1转化成二进制为$0.000\dot110\dot0$，故符号位为 0，指数部分为-4，实际储存为$-4+1023=1019$，转化成二进制为``1111111011`` ，由于是``11 bits``，故为``01111111011`` ，尾数部分为``11001100110011001100110011001100110011001100110011001 ``(53位，最后一位1后面跟的也是1)，

舍去第一位的1，故得到``11001100110011001100110011001100110011001100110011001``，再最后一位进行0舍1入，由于最后一位跟的是1，所以最后一位加1，所以最终得到储存结果``11001100110011001100110011001100110011001100110011010``。最终0.1储存结果为：

```
0	01111111011	1001100110011001100110011001100110011001100110011010
```

同理，0.2的储存结果为：

```
0  01111111100  1001100110011001100110011001100110011001100110011010
```

#### 2.浮点数的运算

浮点数的运算分为3个部分：

1. 对阶
2. 求和
3. 规格化

##### 对阶

浮点数加减首先要判断两数的指数位是否相同（小数点位置是否对齐），若两数指数位不同，需要对阶保证指数位相同。对阶时遵守**小阶向大阶看齐原则**，尾数向右移位，每移动一位，指数位加 1 直到指数位相同，即完成对阶。

本示例，0.1 的阶码为 -4 小于 0.2 的阶码 -3，故对 0.1 做移码操作。

```
// 0.1 移动之前
0  01111111011  1001100110011001100110011001100110011001100110011010 

// 0.1 右移 1 位之后尾数最高位空出一位，（0 舍 1 入，此处舍去末尾 0）
0  01111111100   100110011001100110011001100110011001100110011001101(0) 

// 0.1 右移 1 位完成，尾数部分我们是有隐藏掉最高位是 1 的，所以补1
0  01111111100  1100110011001100110011001100110011001100110011001101
```

##### 尾数求和

```
0  01111111100   1100110011001100110011001100110011001100110011001101 // 0.1 
+ 0  01111111100   1001100110011001100110011001100110011001100110011010 // 0.2
= 0  01111111100 100110011001100110011001100110011001100110011001100111 // 产生进位，待处理
```

#### 规格化

由于产生进位，阶码需要 + 1，对应的十进制为 1021，此时阶码为 1021 - 1023（64 位中间值）= -2，此时符号位、指数位如下所示：

```
0  01111111101
```

尾部进位 2 位，去除最高位默认的 1，因最低位为 1 需进行舍入操作（在二进制中是以 0 结尾的），舍入的方法就是在最低有效位上加 1，若为 0 则直接舍去，若为 1 继续加 1。

```
100110011001100110011001100110011001100110011001100111 + 1
=  00110011001100110011001100110011001100110011001101000 // 去除最高位默认的 1
=  00110011001100110011001100110011001100110011001101000 // 最后一位 0 舍去
=  0011001100110011001100110011001100110011001100110100  // 尾数最后结果
```

IEEE 754 中最终存储如下：

```
0  01111111101 0011001100110011001100110011001100110011001100110100
```

最高位为 1，得到的二进制数如下所示：

```
2^-2 * 1.0011001100110011001100110011001100110011001100110100
```

转换为十进制如下所示：

```
0.30000000000000004
```

### 参考

1. https://zhuanlan.zhihu.com/p/103254614
2. https://en.wikipedia.org/wiki/IEEE_754